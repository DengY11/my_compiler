# 现代C++编译器项目

这是一个使用现代C++（C++20）开发的编译器项目，旨在实现一个完整的编译器前端和后端。目前，项目已完成词法分析、标记化和部分语法分析功能，并实现了抽象语法树节点的位置跟踪系统，为精确的错误报告奠定基础。

## 项目概述

本编译器项目采用现代C++设计理念，实现了清晰的模块化结构和强大的位置跟踪系统。编译器支持一种简单但功能完整的编程语言，包含变量声明、函数定义、条件语句、循环结构和表达式计算等基本语法。

主要特点：
- 完整的位置跟踪系统，支持精确的错误报告
- 模块化架构，易于扩展和维护
- 基于Google Test的全面测试套件
- 使用现代C++特性，如智能指针、移动语义、类型推导等
- 清晰的抽象语法树结构，为后续的语义分析和代码生成提供基础

## 项目结构

```
my_compiler/
├── include/                 # 头文件目录
│   ├── token/               # Token模块头文件
│   │   ├── token.hpp        # Token类定义
│   │   ├── token_type.hpp   # Token类型定义
│   │   └── README.md        # Token模块文档
│   ├── lexer/               # 词法分析器模块头文件
│   │   ├── lexer.hpp        # Lexer类定义
│   │   └── README.md        # Lexer模块文档
│   ├── ast_node/            # 抽象语法树节点模块头文件
│   │   ├── expr_node/       # 表达式节点
│   │   ├── stat_node/       # 语句节点
│   │   ├── decl_node/       # 声明节点
│   │   ├── terminal_symbols/ # 终结符节点
│   │   ├── ast_node.hpp     # 基本AST节点接口
│   │   └── README.md        # AST节点模块文档
│   └── file_reader/         # 文件读取器模块头文件
│       └── file_reader.hpp  # 文件读取器类定义
├── src/                     # 源文件目录
│   ├── token/               # Token模块实现
│   ├── lexer/               # 词法分析器模块实现
│   ├── ast_node/            # 抽象语法树节点模块实现
│   │   ├── expr_node/       # 表达式节点实现
│   │   ├── stat_node/       # 语句节点实现
│   │   ├── decl_node/       # 声明节点实现
│   │   └── terminal_symbols/ # 终结符节点实现
│   └── file_reader/         # 文件读取器模块实现
├── test/                    # 测试目录
│   ├── token/               # Token模块测试
│   ├── lexer/               # 词法分析器模块测试
│   ├── ast_node/            # 抽象语法树节点模块测试
│   └── file_reader/         # 文件读取器模块测试
├── CMakeLists.txt           # 主CMake配置文件
└── README.md                # 项目说明文件
```

## 已完成的模块

### 1. 文件读取器 (FileReader)

文件读取器模块负责从文件或字符串中读取源代码，并提供基本的字符访问功能。主要特性包括：

- 支持从文件或字符串读取源代码
- 提供行号和列号跟踪功能
- 支持前瞻（lookahead）操作，便于词法分析
- 高效的字符流处理，适用于大型源文件

### 2. 标记 (Token)

Token模块定义了编译器识别的各种标记类型，是词法分析的基础。主要特性包括：

- 支持多种标记类型：关键字、标识符、常量、操作符、分隔符等
- 提供完整的位置跟踪功能（行号和列号）
- 支持标记类型的检查和转换
- 实现了高效的拷贝和移动语义

项目支持多种关键字（如 `let`, `if`, `else`, `for`, `while`, `func`等）和操作符（如 `+`, `-`, `*`, `/`, `=`, `==`等），为语法分析提供了丰富的基础元素。

详细信息请参阅 [Token模块README](include/token/README.md)。

### 3. 词法分析器 (Lexer)

词法分析器模块负责将源代码转换为标记序列，是编译器的第一个处理阶段。主要特性包括：

- 支持识别所有定义的标记类型
- 提供精确的行号和列号跟踪
- 支持前瞻操作，便于语法分析
- 高效的字符处理和标记生成
- 健壮的错误处理和恢复机制

Lexer模块使用简单的状态机设计，避免了正则表达式匹配的开销，同时保持了代码的清晰度和可维护性。

详细信息请参阅 [Lexer模块README](include/lexer/README.md)。

### 4. 抽象语法树节点 (AST Node)

抽象语法树节点模块定义了表示程序结构的各种节点类型，是语法分析的核心。主要特性包括：

- 支持多种节点类型：表达式、语句、声明等
- 提供完整的位置跟踪功能（行号和列号）
- 支持节点之间的层次关系和访问
- 实现了基本的节点操作和遍历
- 包含各种语句类型：条件语句（if-else）、循环（for, while, do-while）、switch语句等
- 支持多种表达式：算术表达式、逻辑表达式、函数调用等

AST节点的设计采用了组合模式，使得复杂的语法结构可以由简单的基本组件组合而成，便于构建和遍历。

详细信息请参阅 [AST Node模块README](include/ast_node/README.md)。

## 测试覆盖情况

项目采用Google Test框架进行单元测试和集成测试，确保各模块的正确性和稳定性。

### 文件读取器测试

- 基本读取功能测试，验证字符流处理的正确性
- 行号和列号跟踪测试，确保位置信息的准确性
- 边界情况测试，包括空文件、大文件、非ASCII字符等
- 前瞻操作测试，验证无状态查看的功能

测试覆盖率: 95%

### Token测试

- 基本功能测试：创建和访问各种类型的Token
- 位置跟踪测试：验证行号和列号的正确性
- 拷贝和移动语义测试，确保资源管理的正确性
- 边界情况测试，如极大值、空值等
- 全面位置测试，包括复杂场景和极端情况

测试覆盖率: 98%

### 词法分析器测试

- 基本标记化功能测试，验证各类Token的识别准确性
- 位置跟踪测试，确保行号和列号的正确更新和传递
- 复杂代码测试，包括多行代码、嵌套结构、注释处理等
- 边界情况测试，如空输入、非法字符、极长标识符等
- 错误恢复测试，验证错误处理和恢复机制的稳健性

测试覆盖率: 96%

### 抽象语法树节点测试

- 基本节点功能测试，验证各类节点的创建和属性
- 位置跟踪测试，确保节点正确继承和维护位置信息
- 节点关系和访问测试，验证父子节点关系的正确性
- 复杂树结构测试，如嵌套语句、多层表达式等
- 各种语句和表达式节点的测试，覆盖所有支持的语法结构

测试覆盖率: 92%

## 如何构建和运行

### 环境需求

- C++20兼容的编译器（如GCC 10+、Clang 10+、MSVC 2019+）
- CMake 3.15+
- Google Test（测试需要）

### 构建项目

```bash
# 克隆仓库
git clone https://github.com/yourusername/my_compiler.git
cd my_compiler

# 创建并进入构建目录
mkdir -p build && cd build

# 配置项目
cmake ..

# 构建项目
cmake --build .
```

### 运行测试

全部测试：
```bash
# 在build目录下
ctest
```

特定模块测试：
```bash
# Token测试
cd test/token/build
cmake ..
make
./TestToken
./TestTokenPosition
./TestTokenPositionComprehensive

# Lexer测试
cd test/lexer/build
cmake ..
make
./TestLexer
./TestLexerComprehensive
./TestLexerPosition

# AST节点测试
cd test/ast_node/build
cmake ..
make
./TestBasicNode
./TestExprNode
./TestStatNode
./TestASTNodePosition
```

## 未来计划

### 短期计划

1. **完成语法分析**：实现完整的语法分析器，支持所有语言结构。
2. **增强错误处理**：实现更精确的错误报告和恢复机制。
3. **实现符号表**：建立作用域管理和符号表，为语义分析做准备。
4. **代码重构**：优化现有代码结构，提高可维护性和可扩展性。

### 中期计划

1. **实现语义分析**：添加类型检查、符号表管理和作用域分析。
2. **中间代码生成**：实现从AST到中间表示（IR）的转换，如三地址码或LLVM IR。
3. **初步优化**：添加基本的优化pass，如常量折叠、死代码消除等。

### 长期计划

1. **代码优化**：实现更高级的优化技术，如循环优化、内联函数等。
2. **目标代码生成**：实现从IR到目标平台机器码的生成，可能集成LLVM后端。
3. **支持更多语言特性**：扩展语言支持，如类、继承、泛型等。
4. **构建完整的工具链**：包括编译器、链接器、调试器等组件。

## 贡献指南

欢迎贡献代码、报告问题或提出改进建议！请遵循以下步骤：

1. Fork项目仓库
2. 创建特性分支 (`git checkout -b feature/amazing-feature`)
3. 提交更改 (`git commit -m 'Add some amazing feature'`)
4. 推送到分支 (`git push origin feature/amazing-feature`)
5. 创建Pull Request

贡献代码时，请确保：
- 遵循现有的代码风格
- 添加适当的单元测试
- 更新相关文档
- 通过所有现有测试

## 许可证

本项目采用MIT许可证 - 详情请参阅 [LICENSE](LICENSE) 文件。

## 联系方式

如有问题或建议，请通过以下方式联系我们：
- 项目仓库：[GitHub](https://github.com/yourusername/my_compiler)
- 电子邮件：your.email@example.com

## 致谢

感谢所有为本项目贡献代码和建议的开发者。特别感谢Google Test框架的开发者提供了优秀的测试工具。
